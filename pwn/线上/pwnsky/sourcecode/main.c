#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <seccomp.h>
#include <linux/seccomp.h>
#include <lua.h>
#include <stdlib.h>
#include <stdio.h>

#include <lauxlib.h>
#include <lualib.h>

#include <string.h>
#include <time.h>

#define __int64 long int
#define _BYTE unsigned char

#define i0gan_asm_1 \
    __asm__ __volatile__( \
    "leaq    (%rip), %r8\n\t" \
    "pushq %r8\n\t" \
    "addq $0xd, (%rsp)\n\t" \
    "ret\n\t" \
    "jmp 0xdeed\n\t");
#define MAX_NUM 100

void func();
void menu();
void init();
void key_init();

void pe_encode(unsigned char key[8], void *raw_data, size_t length);
void pe_decode(unsigned char key[8], void *raw_data, size_t length);
void key_random(unsigned char raw_key[8], unsigned char *out_key, unsigned char seed);

char *plist[MAX_NUM];
int   plist_size[MAX_NUM];


unsigned char logo[] = {
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x32, 0x3b, 0x39, 0x32, 0x6d,
  0x23, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31,
  0x3b, 0x33, 0x33, 0x3b, 0x39, 0x33, 0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x3b,
  0x31, 0x3b, 0x33, 0x32, 0x3b, 0x39, 0x32, 0x6d, 0x6d, 0x6d, 0x1b, 0x5b,
  0x30, 0x3b, 0x31, 0x3b, 0x33, 0x36, 0x3b, 0x39, 0x36, 0x6d, 0x6d, 0x1b,
  0x5b, 0x30, 0x6d, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33,
  0x34, 0x3b, 0x39, 0x34, 0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x33, 0x3b,
  0x39, 0x33, 0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x1b, 0x5b, 0x30,
  0x3b, 0x31, 0x3b, 0x33, 0x32, 0x3b, 0x39, 0x32, 0x6d, 0x6d, 0x1b, 0x5b,
  0x30, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x36, 0x3b,
  0x39, 0x36, 0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x34,
  0x3b, 0x39, 0x34, 0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x20,
  0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x31, 0x3b, 0x39, 0x31,
  0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x33, 0x3b, 0x39,
  0x33, 0x6d, 0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x20, 0x1b,
  0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x36, 0x3b, 0x39, 0x36, 0x6d, 0x23,
  0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31,
  0x3b, 0x33, 0x35, 0x3b, 0x39, 0x35, 0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x6d,
  0x20, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x33, 0x3b, 0x39,
  0x33, 0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x20, 0x1b, 0x5b,
  0x30, 0x3b, 0x31, 0x3b, 0x33, 0x36, 0x3b, 0x39, 0x36, 0x6d, 0x6d, 0x1b,
  0x5b, 0x30, 0x6d, 0x20, 0x0a, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b,
  0x33, 0x32, 0x3b, 0x39, 0x32, 0x6d, 0x23, 0x1b, 0x5b, 0x30, 0x3b, 0x31,
  0x3b, 0x33, 0x36, 0x3b, 0x39, 0x36, 0x6d, 0x22, 0x1b, 0x5b, 0x30, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x34, 0x3b, 0x39, 0x34,
  0x6d, 0x22, 0x23, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x3b,
  0x31, 0x3b, 0x33, 0x35, 0x3b, 0x39, 0x35, 0x6d, 0x22, 0x1b, 0x5b, 0x30,
  0x3b, 0x31, 0x3b, 0x33, 0x31, 0x3b, 0x39, 0x31, 0x6d, 0x6d, 0x1b, 0x5b,
  0x30, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x33, 0x3b,
  0x39, 0x33, 0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x1b, 0x5b, 0x30,
  0x3b, 0x31, 0x3b, 0x33, 0x32, 0x3b, 0x39, 0x32, 0x6d, 0x6d, 0x22, 0x1b,
  0x5b, 0x30, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x36,
  0x3b, 0x39, 0x36, 0x6d, 0x23, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33,
  0x34, 0x3b, 0x39, 0x34, 0x6d, 0x22, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20,
  0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x35, 0x3b, 0x39, 0x35, 0x6d,
  0x23, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31,
  0x3b, 0x33, 0x33, 0x3b, 0x39, 0x33, 0x6d, 0x23, 0x1b, 0x5b, 0x30, 0x6d,
  0x20, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x36, 0x3b,
  0x39, 0x36, 0x6d, 0x22, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x1b, 0x5b,
  0x30, 0x3b, 0x31, 0x3b, 0x33, 0x34, 0x3b, 0x39, 0x34, 0x6d, 0x23, 0x1b,
  0x5b, 0x30, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x35,
  0x3b, 0x39, 0x35, 0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33,
  0x31, 0x3b, 0x39, 0x31, 0x6d, 0x22, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20,
  0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x32, 0x3b, 0x39, 0x32,
  0x6d, 0x22, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x3b,
  0x31, 0x3b, 0x33, 0x36, 0x3b, 0x39, 0x36, 0x6d, 0x6d, 0x1b, 0x5b, 0x30,
  0x3b, 0x31, 0x3b, 0x33, 0x34, 0x3b, 0x39, 0x34, 0x6d, 0x22, 0x1b, 0x5b,
  0x30, 0x6d, 0x20, 0x0a, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33,
  0x36, 0x3b, 0x39, 0x36, 0x6d, 0x23, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20,
  0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x35, 0x3b, 0x39, 0x35,
  0x6d, 0x23, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x3b,
  0x31, 0x3b, 0x33, 0x33, 0x3b, 0x39, 0x33, 0x6d, 0x23, 0x6d, 0x1b, 0x5b,
  0x30, 0x3b, 0x31, 0x3b, 0x33, 0x32, 0x3b, 0x39, 0x32, 0x6d, 0x23, 0x6d,
  0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x36, 0x3b, 0x39, 0x36, 0x6d,
  0x23, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31,
  0x3b, 0x33, 0x34, 0x3b, 0x39, 0x34, 0x6d, 0x23, 0x1b, 0x5b, 0x30, 0x6d,
  0x20, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x31, 0x3b,
  0x39, 0x31, 0x6d, 0x23, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x20, 0x1b,
  0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x32, 0x3b, 0x39, 0x32, 0x6d, 0x22,
  0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x36, 0x3b, 0x39, 0x36, 0x6d,
  0x22, 0x22, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x34, 0x3b, 0x39,
  0x34, 0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x1b, 0x5b, 0x30,
  0x3b, 0x31, 0x3b, 0x33, 0x35, 0x3b, 0x39, 0x35, 0x6d, 0x23, 0x1b, 0x5b,
  0x30, 0x3b, 0x31, 0x3b, 0x33, 0x31, 0x3b, 0x39, 0x31, 0x6d, 0x22, 0x23,
  0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x1b, 0x5b, 0x30,
  0x3b, 0x31, 0x3b, 0x33, 0x36, 0x3b, 0x39, 0x36, 0x6d, 0x23, 0x1b, 0x5b,
  0x30, 0x3b, 0x31, 0x3b, 0x33, 0x34, 0x3b, 0x39, 0x34, 0x6d, 0x6d, 0x23,
  0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x0a, 0x20, 0x1b, 0x5b, 0x30, 0x3b,
  0x31, 0x3b, 0x33, 0x34, 0x3b, 0x39, 0x34, 0x6d, 0x23, 0x1b, 0x5b, 0x30,
  0x3b, 0x31, 0x3b, 0x33, 0x35, 0x3b, 0x39, 0x35, 0x6d, 0x23, 0x6d, 0x1b,
  0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x31, 0x3b, 0x39, 0x31, 0x6d, 0x23,
  0x22, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x3b,
  0x31, 0x3b, 0x33, 0x32, 0x3b, 0x39, 0x32, 0x6d, 0x23, 0x1b, 0x5b, 0x30,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x36, 0x3b, 0x39,
  0x36, 0x6d, 0x23, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x20, 0x1b, 0x5b,
  0x30, 0x3b, 0x31, 0x3b, 0x33, 0x35, 0x3b, 0x39, 0x35, 0x6d, 0x23, 0x1b,
  0x5b, 0x30, 0x6d, 0x20, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b,
  0x33, 0x33, 0x3b, 0x39, 0x33, 0x6d, 0x23, 0x1b, 0x5b, 0x30, 0x6d, 0x20,
  0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x36, 0x3b, 0x39, 0x36,
  0x6d, 0x22, 0x6d, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x34, 0x3b,
  0x39, 0x34, 0x6d, 0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33,
  0x35, 0x3b, 0x39, 0x35, 0x6d, 0x22, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20,
  0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x31, 0x3b, 0x39, 0x31, 0x6d,
  0x23, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31,
  0x3b, 0x33, 0x32, 0x3b, 0x39, 0x32, 0x6d, 0x22, 0x6d, 0x1b, 0x5b, 0x30,
  0x6d, 0x20, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x34,
  0x3b, 0x39, 0x34, 0x6d, 0x22, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33,
  0x35, 0x3b, 0x39, 0x35, 0x6d, 0x23, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20,
  0x20, 0x0a, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b, 0x33, 0x35, 0x3b,
  0x39, 0x35, 0x6d, 0x23, 0x1b, 0x5b, 0x30, 0x6d, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31,
  0x3b, 0x33, 0x35, 0x3b, 0x39, 0x35, 0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x3b,
  0x31, 0x3b, 0x33, 0x31, 0x3b, 0x39, 0x31, 0x6d, 0x22, 0x1b, 0x5b, 0x30,
  0x6d, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x1b, 0x5b, 0x30, 0x3b, 0x31, 0x3b,
  0x33, 0x31, 0x3b, 0x39, 0x31, 0x6d, 0x22, 0x1b, 0x5b, 0x30, 0x6d, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x1b, 0x5b, 0x30,
  0x3b, 0x31, 0x3b, 0x33, 0x31, 0x3b, 0x39, 0x31, 0x6d, 0x22, 0x22, 0x1b,
  0x5b, 0x30, 0x6d, 0x20, 0x20, 0x20, 0x20, 0x0a
};
unsigned int logo_len = 1316;
__int64 key = 0; // key

// key length is 8 bytes
// 加密概述: 密码类型: 流密码
// 采用密钥重叠循环，查表来进行异或。
unsigned char xor_table_[256] = {
    0xbe, 0xd1, 0x90, 0x88, 0x57, 0x00, 0xe9, 0x53, 0x10, 0xbd, 0x2a, 0x34, 0x51, 0x84, 0x07, 0xc4,
    0x33, 0xc5, 0x3b, 0x53, 0x5f, 0xa8, 0x5d, 0x4b, 0x6d, 0x22, 0x63, 0x5d, 0x3c, 0xbd, 0x47, 0x6d,
    0x22, 0x3f, 0x38, 0x4b, 0x7a, 0x4c, 0xb8, 0xcc, 0xb8, 0x37, 0x78, 0x17, 0x73, 0x23, 0x27, 0x71,
    0xb1, 0xc7, 0xa6, 0xd1, 0xa0, 0x48, 0x21, 0xc4, 0x1b, 0x0a, 0xad, 0xc9, 0xa5, 0xe6, 0x14, 0x18,
    0xfc, 0x7b, 0x53, 0x59, 0x8b, 0x0d, 0x07, 0xcd, 0x07, 0xcc, 0xbc, 0xa5, 0xe0, 0x28, 0x0e, 0xf9,
    0x31, 0xc8, 0xed, 0x78, 0xf4, 0x75, 0x60, 0x65, 0x52, 0xb4, 0xfb, 0xbf, 0xac, 0x6e, 0xea, 0x5d,
    0xca, 0x0d, 0xb5, 0x66, 0xac, 0xba, 0x06, 0x30, 0x95, 0xf4, 0x96, 0x42, 0x7a, 0x7f, 0x58, 0x6d,
    0x83, 0x8e, 0xf6, 0x61, 0x7c, 0x0e, 0xfd, 0x09, 0x6e, 0x42, 0x6b, 0x1e, 0xb9, 0x14, 0x22, 0xf6,

    0x16, 0xd2, 0xd2, 0x60, 0x29, 0x23, 0x32, 0x9e, 0xb4, 0x82, 0xee, 0x58, 0x3a, 0x7d, 0x1f, 0x74,
    0x98, 0x5d, 0x17, 0x64, 0xe4, 0x6f, 0xf5, 0xad, 0x94, 0xaa, 0x89, 0xe3, 0xbe, 0x98, 0x91, 0x38,
    0x70, 0xec, 0x2f, 0x5e, 0x9f, 0xc9, 0xb1, 0x26, 0x3a, 0x64, 0x48, 0x13, 0xf1, 0x1a, 0xc5, 0xd5,
    0xe5, 0x66, 0x11, 0x11, 0x3a, 0xaa, 0x79, 0x45, 0x42, 0xb4, 0x57, 0x9d, 0x3f, 0xbc, 0xa3, 0xaa,
    0x98, 0x4e, 0x6b, 0x7a, 0x4a, 0x2f, 0x3e, 0x10, 0x7a, 0xc5, 0x33, 0x8d, 0xac, 0x0b, 0x79, 0x33,
    0x5d, 0x09, 0xfc, 0x9d, 0x9b, 0xe5, 0x18, 0xcd, 0x1c, 0x7c, 0x8b, 0x0a, 0xa8, 0x95, 0x56, 0xcc,
    0x4e, 0x34, 0x31, 0x33, 0xf5, 0xc1, 0xf5, 0x03, 0x0a, 0x4a, 0xb4, 0xd1, 0x90, 0xf1, 0x8f, 0x57,
    0x20, 0x05, 0x0d, 0xa0, 0xcd, 0x82, 0xb3, 0x25, 0xd8, 0xd2, 0x20, 0xf3, 0xc5, 0x96, 0x35, 0x35,
};
void pe_encode(unsigned char key[8], void *raw_data, size_t length) {
    unsigned char keys[8];
    memcpy(keys, key, 8);
    char *data = (char *)raw_data;
    for(int i = 0; i < length; i ++) {
        unsigned char n = ((keys[i & 7] + keys[(i + 1) & 7]) * keys[(i + 2) & 7] + keys[(i + 3) & 7]) & 0xff;
        data[i] ^= n ^ xor_table_[n];
        keys[i & 7] = (n * 2 + 3) & 0xff;

        if((i & 0xf) == 0) {
            key_random(key, keys, xor_table_[i & 0xff]);
        }
    }
}

/*
// 解密
void pe_decode(unsigned char key[8], void *raw_data, size_t length) {
    unsigned char keys[8];
    memcpy(keys, key, 8);
    char *data = (char *)raw_data;
    int j = 0;
    for(int i = 0; i < length; i ++) {
        unsigned char n = ((keys[i & 7] + keys[(i + 1) & 7]) * keys[(i + 2) & 7] + keys[(i + 3) & 7]) & 0xff;
        data[i] ^= n ^ xor_table_[n];
        keys[i & 7] = (n * 2 + 3) & 0xff;

        if((i & 0xf) == 0) {
            key_random(key, keys, xor_table_[i & 0xff]);
        }
    }
}
*/

void key_random(unsigned char raw_key[8], unsigned char *out_key, unsigned char seed) {
    i0gan_asm_1
    for(int i = 0; i < 8; i ++)  {
        out_key[i] = (raw_key[i] ^ xor_table_[raw_key[i]]) & 0xff;
        out_key[i] ^= seed + (unsigned char)i;
    }
}

void sandbox() {
    scmp_filter_ctx ctx;
    ctx = seccomp_init(SCMP_ACT_ALLOW);
    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);
    if(seccomp_load(ctx) < -2){
        exit(0);
    }
}

void buffer_init() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);
}

void init() {
    buffer_init();
    sandbox();
    key_init();
}

/*
__int64 key_decode(__int64 data) {
    unsigned int low, high, seed;
    int map[4];
    __int64 result;
    map[0] = 0x12345678;
    map[1] = 0x87654321;
    map[2] = 0xdeedbeef;
    map[3] = 0xbeefdeed;
    high = data >> 32;
    low = data & 0xffffffff;
    seed = 0xf515354c;
    for (int i = 0; i <= 31; ++i) {
      low += (((high >> 5) ^ (16 * high)) + high) ^ (map[seed & 3] + seed);
      seed -= 0x41424344;
      high += (((low >> 5) ^ (16 * low)) + low) ^ (map[(seed >> 11) & 3] + seed);
    }
    result = high;
    result <<= 32;
    result += low;
    return result; 
}

__int64 key_encode(__int64 data) {
    unsigned int low, high, seed;
    int map[4];
    __int64 result;
    map[0] = 0x12345678;
    map[1] = 0x87654321;
    map[2] = 0xdeedbeef;
    map[3] = 0xbeefdeed;
    high = data >> 32;
    low = data & 0xffffffff;
    seed = 0xcccccccc;
    for (int i = 0; i <= 31; ++i) {
      high -= (((low >> 5) ^ (16 * low)) + low) ^ (map[(seed >> 11) & 3] + seed);
      seed += 0x41424344;
      low -= (((high >> 5) ^ (16 * high)) + high) ^ (map[seed & 3] + seed);
    }
    result = high;
    result <<= 32;
    result += low;
    return result; 
}*/

// 返回值代表是login的压入栈的数量
int login(lua_State *L) {
    int account, password;
    if (!lua_isnumber(L, -1)) {
        error(L, "In function: login, password argument must a number");
        return 0; 
    }
    password = (int)lua_tonumber(L, -1);
    lua_pop(L, 1);

    if (!lua_isnumber(L, -1)) {
        error(L, "In function: login, account argument must a number");
        return 0; 
    }
    account = (int)lua_tonumber(L, -1);
    lua_pop(L, 1);
    pe_encode(&key, &password, 4);
    //printf("password: %d\n", password);
    // password: 418894113
    if(account == 1000 && password == 1904107080) {
        lua_pushinteger(L, 1);
    } else {
        lua_pushinteger(L, 0);
    }
    return 1;
}

int add_data(lua_State *L) {
    int size, idx;
    if (!lua_isnumber(L, -1)) {
        error(L, "In function: add_data, first argument must a number");
        return 0; 
    }
    size = (int)lua_tonumber(L, -1);
    lua_pop(L, 1);

    for(idx = 0; idx <= MAX_NUM; ++idx) {
        if(plist[idx] == NULL) {
            break;
        }
        if(idx == MAX_NUM) {
            return 0;
        }
    }

    if(size <= 0 || size >= 0x1000) {
        return 0;
    }

    plist[idx] = malloc(size);
    size_t i = 0;
    int read_sum = 0;
    for(i = 0; i < size; ++i) {
        int read_len = read(0, plist[idx] + i, 1);
        if(*(plist[idx] + i) == '\n')
            break;
        if(read_len > 0) read_sum += read_len;
    }

    plist_size[idx] = size;
    pe_encode(&key, plist[idx], read_sum);
    lua_pushinteger(L, idx);
    printf("gift: %llx\n", (long long)plist[idx] & 0xfff);
    i0gan_asm_1

    if(plist[idx][0] == 0)
        read(0, plist[idx] + i, 1);
    return 1;
}

int delete_data(lua_State *L) {
    int idx;
    if (!lua_isnumber(L, -1)) {
        error(L, "In function: delete_data, first argument must a number");
        return 0; 
    }

    idx = (int)lua_tonumber(L, -1);
    lua_pop(L, 1);

    if(idx < 0 || idx >= MAX_NUM) return 0;
    if(plist[idx] == NULL) {
        error(L, "delete index error");
        return 0;
    }

    free(plist[idx]);
    plist[idx] = NULL;
    plist_size[idx] = 0;
    return 0;
}

int get_data(lua_State *L) {
    int idx;
    if (!lua_isnumber(L, -1)) {
        error(L, "In function: get_data, first argument must a number");
        return 0; 
    }
    idx = (int)lua_tonumber(L, -1);
    lua_pop(L, 1);

    if(idx < 0 || idx >= MAX_NUM) return 0;
    if(plist[idx] == NULL) {
        return 0;
    }
    write(1, plist[idx], plist_size[idx]);
    return 0;
}

int print_logo() {
    write(1, logo, logo_len);
    return 0;
}

__int64 key_genarator() {
    __int64 key;
    time_t t = time(0);
    srand(0);
    key = rand();
    key <<= 32; 
    key += rand();
    return key;
}

void key_init() {
    key = key_genarator();
}

int lua_alarm(lua_State *L) {
    int time;
    if(!lua_isnumber(L, -1))
        error(L, "function timeout_to_end argument must be a number");
    time = lua_tonumber(L, -1);
    lua_pop(L, 1);
    alarm(time);
    return 0;
}

lua_State* lua_init() {
    lua_State *L = NULL;
    L = luaL_newstate();
    luaL_openlibs(L);
    if(luaL_dofile(L, "lua.bin")) {
        puts("lua.bin file not found!");
        //return NULL;
    }

    lua_register(L, "print_logo", print_logo);
    lua_register(L, "init", init);
    lua_register(L, "login", login);
    lua_register(L, "alarm", lua_alarm);
    lua_register(L, "add_data", add_data);
    lua_register(L, "delete_data", delete_data);
    lua_register(L, "get_data", get_data);

    return L;
}

int main(int, char**) {
    lua_State *L = NULL;
    L = lua_init();
    lua_getglobal(L, "main");
    lua_pcall(L, 0, 0, 0);
    lua_close(L);
    
    return 0;
}
